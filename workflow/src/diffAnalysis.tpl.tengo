// run annotation and DE analysis
self := import("@platforma-sdk/workflow-tengo:tpl")
smart := import("@platforma-sdk/workflow-tengo:smart")
ll := import("@platforma-sdk/workflow-tengo:ll")
exec := import("@platforma-sdk/workflow-tengo:exec")
assets := import("@platforma-sdk/workflow-tengo:assets")
pframes := import("@platforma-sdk/workflow-tengo:pframes")
xsv := import("@platforma-sdk/workflow-tengo:pframes.xsv")
pSpec := import("@platforma-sdk/workflow-tengo:pframes.spec")

topTablePfconvParamsLib := import(":top_table_pfconv_params")
dcaPfconvParamsLib := import(":dca_pfconv_params")
json := import("json")


self.validateInputs({
	"__options__,closed": "",
	continueOrNot: "any",
	allCounts: "any",
	csvCovariates: "any",
	numerators: "any",
	denominator: "any",
	contrastFactor: "any",
	params: {
		"__options__,closed": "",
		"log2FcThreshold,omitempty": "number",
		"pAdjThreshold,omitempty": "number",
		"defaultConvMem,omitempty": "string",
		"defaultConvCpu,omitempty": "number"
	},
	metaInputs: {
		"__options__,closed": "",
		"blockId,omitempty": "string"
	}
})

self.defineOutputs("degPF", "regDirPF", "topDegPF")

self.body(func(inputs) {
	degPF := {}
	topDegPF := {}
	regDirPF := {}
	defaultConvMem := inputs.params.defaultConvMem
	defaultConvCpu := inputs.params.defaultConvCpu
	contrastFactor := inputs.contrastFactor
	denominator := string(inputs.denominator)
	log2FcThreshold := inputs.params.log2FcThreshold
	pAdjThreshold := inputs.params.pAdjThreshold
	blockId := inputs.metaInputs.blockId
	
	if string(inputs.continueOrNot.getData()) != "continue" {
		// If matrix is not full rank return empty objects
		return {
			degPF: degPF,
			regDirPF: regDirPF,
			topDegPF: topDegPF
		}

	} else {
		// Proceed only if metadata matrix is full rank
		
		degPframeBuilder := pframes.pFrameBuilder()
		regDirPframeBuilder := pframes.pFrameBuilder()
		topDegPframeBuilder := pframes.pFrameBuilder()

		countsSpec := inputs.allCounts.spec

		// convert PColumns to csv
		csvCounts := xsv.exportFrame([inputs.allCounts], "csv", {mem: defaultConvMem, cpu: defaultConvCpu})

		// Create PFrames for DEG, regulation direction and topTable
		for numerator in inputs.numerators {
			numerator = string(numerator)
			diffAbundance := exec.builder().
					software(assets.importSoftware("@platforma-open/milaboratories.run-diff-clonotype-abundance-deseq2-r.software:main")).
					arg("-c").arg("rawCounts.csv").
					arg("-m").arg("covariates.csv").
					arg("-t").arg(contrastFactor.spec.annotations["pl7.app/label"]). 
					arg("-n").arg(string(numerator)).
					arg("-d").arg(string(denominator)).
					arg("-o").arg("topTable.csv").
					arg("-f").arg(string(log2FcThreshold)).
					arg("-p").arg(string(pAdjThreshold)).
					arg("--values_column").arg(countsSpec.annotations["pl7.app/label"]).
					arg("--IDs_column").arg(countsSpec.axesSpec[1].annotations["pl7.app/label"]).
					arg("--min_counts").arg("1").
					// @TODO: improve filter, right now is min_counts in at least one sample
					// fraction_for_filter value is set to at least 1 in R code
					arg("--fraction_for_filter").arg("0.01").
					addFile("rawCounts.csv", csvCounts).
					addFile("covariates.csv", inputs.csvCovariates).
					saveFile("topTable.csv").
					saveFile("DEG.csv").
					printErrStreamToStdout().
					saveStdoutContent().
					cache(24 * 60 * 60 * 1000).
					run()
					
			topTableImportParams := topTablePfconvParamsLib.getColumns(countsSpec,
																	log2FcThreshold,
																	pAdjThreshold)
			topTablePf := xsv.importFile(diffAbundance.getFile("topTable.csv"), "csv", topTableImportParams, 
																// This changes output format from default to per column
																// So key will be column name and values spec and data
																{splitDataAndSpec: true, mem: defaultConvMem, cpu: defaultConvCpu})

			// Add DEG export with specific import params. Adding new csv output to script with only DEGs and logFC
			degImportParams := dcaPfconvParamsLib.getColumns(countsSpec)
			DegPf := xsv.importFile(diffAbundance.getFile("DEG.csv"), "csv", degImportParams, {mem: defaultConvMem, cpu: defaultConvCpu})

			trace := pSpec.makeTrace(countsSpec,
				{type: "milaboratories.differential-clonotype-abundance", id: blockId, importance: 30, 
				label: "DCA - " + numerator + "/" + denominator + " (log2FC: " + log2FcThreshold + ", pAdj: " + pAdjThreshold + ")"}
			)
			
			comparison := numerator + " - vs - " + denominator

			for columnName, value in topTablePf { 
				columnSpec := copy(value.spec)
				columnSpec.axesSpec[0].domain["pl7.app/differentialAbundance/comparison"] = comparison
				columnData := value.data
				topDegPframeBuilder.add(
					numerator + " - " + columnName,
					trace.inject(columnSpec),
					columnData

				)
			}

			// Get runID label
			runIdLabel := countsSpec.axesSpec[1].domain["pl7.app/vdj/clonotypingRunId"]
			if runIdLabel == undefined {
				runIdLabel = "pl7.app/vdj/vdjImport"
			} else {
				runIdLabel = "pl7.app/vdj/clonotypingRunId"
			}
		

			degPframeBuilder.add(
				numerator,
				trace.inject({
					kind: "PColumn",
					name: "pl7.app/differentialAbundance/DCA",
					domain: {
						runIdLabel: countsSpec.axesSpec[1].domain[runIdLabel],
						"pl7.app/differentialAbundance/comparison": comparison
					},
					valueType: "Double",
					annotations: {
						"pl7.app/label": comparison + " (log2FC)",
						"pl7.app/isAbundance": "true",
						"pl7.app/table/visibility": "default",
						"pl7.app/table/orderPriority": "85000"
					},
					axesSpec: [
						countsSpec.axesSpec[1]
						]
				}),
				DegPf["log2foldchange.data"]
			)

			regDirPframeBuilder.add(
				numerator,
				trace.inject({
					kind: "PColumn",
					name: "pl7.app/differentialAbundance/regulationDirection",
					domain: {
						runIdLabel: countsSpec.axesSpec[1].domain[runIdLabel],
						"pl7.app/differentialAbundance/comparison": comparison
					},
					valueType: "String",
					annotations: {
						"pl7.app/label": comparison + " (UP\\Down-regulated clonotype list)",
						"pl7.app/isAbundance": "true",
						"pl7.app/table/visibility": "optional",
						"pl7.app/table/orderPriority": "84000"

					},
					axesSpec: [
						countsSpec.axesSpec[1]
						]
				}),
				DegPf["regulationDirection.data"]
			)
		}
		

		// Build the final PFrames
		degPF = degPframeBuilder.build()
		topDegPF = topDegPframeBuilder.build()
		regDirPF = regDirPframeBuilder.build()

		return {
			degPF: degPF,
			regDirPF: regDirPF,
			topDegPF: pframes.exportFrame(topDegPF)
		}
	} 
})
