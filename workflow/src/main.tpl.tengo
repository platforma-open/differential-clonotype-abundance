// "hello world"
wf := import("@platforma-sdk/workflow-tengo:workflow")
exec := import("@platforma-sdk/workflow-tengo:exec")
assets:= import("@platforma-sdk/workflow-tengo:assets")
xsv := import("@platforma-sdk/workflow-tengo:pframes.xsv")
pframes := import("@platforma-sdk/workflow-tengo:pframes")
render := import("@platforma-sdk/workflow-tengo:render")
ll := import("@platforma-sdk/workflow-tengo:ll")

pfErrorLogsConv := import(":pf-de-errors-conv")
diffAnalysisTpl := assets.importTemplate(":diffAnalysis")

wf.prepare(func(args){

	// below solution not working currently
	metaRefs := {}

	i := 0
	for metaRef in args.covariateRefs {
		metaRefs["metaRef" + i ] = wf.resolve(metaRef, { errIfMissing: true })
		i = i + 1
	}

	return {
		resolvedInput: wf.resolve(args.countsRef, { errIfMissing: true }),
		resolvedContrastFactor: wf.resolve(args.contrastFactor),
		metaRefs: metaRefs
	}
})

wf.body(func(args) {
	blockId := wf.blockId().getDataAsJson()

	allCounts := args.resolvedInput
	countsSpec := allCounts.spec

	contrastFactor := args.resolvedContrastFactor
	denominator := string(args.denominator)
	log2FcThreshold := args.log2FcThreshold
	pAdjThreshold := args.pAdjThreshold

	// Get type of input
	inputType := undefined
	if (countsSpec.axesSpec[1].name == "pl7.app/vdj/clonotypeKey") {
		inputType = "clonotype"
	} else if (countsSpec.axesSpec[1].name == "pl7.app/rna-seq/geneId") {
		inputType = "gene"
	} else {
		ll.panic("Not yet supported input data. Please contact Milaboratories to include it:\n%v", countsSpec)
	}

	// Set default conversion memory and CPU
	defaultConvMem := "16GiB"
	defaultConvCpu := 1

	covariates := []
	for _, v in args.metaRefs {
		covariates = append(covariates, v)
	}
	
	// convert PColumns to csv
	csvCovariates := xsv.exportFrame(covariates, "csv", {mem: defaultConvMem, cpu: defaultConvCpu})

	// Run script to check if metadata matrix will be full rank
	continueCheck := exec.builder().
			software(assets.importSoftware("@platforma-open/milaboratories.run-diff-clonotype-abundance-deseq2-r.software:prev-checks")).
			arg("--output").arg(".").
			arg("--metadata").arg("covariates.csv").
			addFile("covariates.csv", csvCovariates).
			arg("--contrast_factor").arg(contrastFactor.spec.annotations["pl7.app/label"]).
			arg("--numerators").arg(string(args.numerators)).
			arg("--denominator").arg(denominator).
			arg("--error_output").arg("./errorLogs.csv").
			saveFileContent("continueOrNot.txt").
			saveFile("errorLogs.csv").
			cache(24 * 60 * 60 * 1000).
			run()

	// This content is resolved in a sub-template only
	continueOrNot := continueCheck.getFileContent("continueOrNot.txt")

	errorLogsImportParams := pfErrorLogsConv.getColumns()
	errorLogsPf := xsv.importFile(continueCheck.getFile("errorLogs.csv"), "csv", errorLogsImportParams, { mem: defaultConvMem, cpu: defaultConvCpu })

	// Run differential analysis template
	// Analysis will only run if matrix is full rank (continueOrNot.txt content == "continue")
	diffAnalysis := render.create(diffAnalysisTpl, {
		continueOrNot: continueOrNot,
		allCounts: allCounts,
		csvCovariates: csvCovariates,
		numerators: args.numerators,
		denominator: denominator,
		contrastFactor: contrastFactor,
		params: {
			log2FcThreshold: log2FcThreshold,
			pAdjThreshold: pAdjThreshold,
			defaultConvMem: defaultConvMem,
			defaultConvCpu: defaultConvCpu,
			inputType: inputType
		},
		metaInputs: {
			blockId: blockId
		}
	})

	// Gather results from continueCheck template
	degPF := diffAnalysis.output("degPF")
	regDirPF := diffAnalysis.output("regDirPF")
	topDegPF := diffAnalysis.output("topDegPF")
	contrastExport := diffAnalysis.output("contrastExport")

	exports := {
		DEG: degPF,
		regDir: regDirPF,
		contrastExport: contrastExport
	}

	return {
		outputs: {
			topTablePf: topDegPF,
			errorLogs: pframes.exportFrame(errorLogsPf)
		},
		exports: exports
	}
})


