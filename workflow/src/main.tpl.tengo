// "hello world"
wf := import("@platforma-sdk/workflow-tengo:workflow")
exec := import("@platforma-sdk/workflow-tengo:exec")
assets:= import("@platforma-sdk/workflow-tengo:assets")
xsv := import("@platforma-sdk/workflow-tengo:pframes.xsv")
pframes := import("@platforma-sdk/workflow-tengo:pframes")
render := import("@platforma-sdk/workflow-tengo:render")
ll := import("@platforma-sdk/workflow-tengo:ll")

pfErrorLogsConv := import(":pf-de-errors-conv")
diffAnalysisTpl := assets.importTemplate(":diffAnalysis")

wf.prepare(func(args){

	// below solution not working currently
	metaRefs := {}

	i := 0
	for metaRef in args.covariateRefs {
		metaRefs["metaRef" + i ] = wf.resolve(metaRef, { errIfMissing: true })
		i = i + 1
	}

	return {
		resolvedInput: wf.resolve(args.countsRef, { errIfMissing: true }),
		resolvedContrastFactor: wf.resolve(args.contrastFactor),
		metaRefs: metaRefs
	}
})

wf.body(func(args) {
	blockId := wf.blockId().getDataAsJson()

	allCounts := args.resolvedInput
	countsSpec := allCounts.spec

	contrastFactor := args.resolvedContrastFactor
	denominator := string(args.denominator)
	log2FcThreshold := args.log2FcThreshold
	pAdjThreshold := args.pAdjThreshold

	// Get type of input
	inputType := undefined
	if (countsSpec.axesSpec[1].name == "pl7.app/vdj/clonotypeKey" || countsSpec.axesSpec[1].name == "pl7.app/vdj/scClonotypeKey") {
		inputType = "Clonotype"
	} else if (countsSpec.axesSpec[1].name == "pl7.app/rna-seq/geneId") {
		inputType = "Gene"
	} else if (countsSpec.axesSpec[1].name == "pl7.app/vdj/clusterId") {
		inputType = "Cluster"
	} else {
		ll.panic("\n\nNot yet supported input data. Please contact Milaboratories to include it:\n%v\n", countsSpec)
	}

	// Set default conversion memory and CPU
	defaultConvMem := "16GiB"
	defaultConvCpu := 1

	covariates := []
	for _, v in args.metaRefs {
		covariates = append(covariates, v)
	}
	
	// convert PColumns to csv
	csvCovariates := xsv.exportFrame(covariates, "csv", {mem: defaultConvMem, cpu: defaultConvCpu})

	// Run script to check if metadata matrix will be full rank
	continueCheck := exec.builder().
			software(assets.importSoftware("@platforma-open/milaboratories.run-diff-clonotype-abundance-deseq2-r.software:prev-checks")).
			arg("--output").arg(".").
			arg("--metadata").arg("covariates.csv").
			addFile("covariates.csv", csvCovariates).
			arg("--contrast_factor").arg(contrastFactor.spec.annotations["pl7.app/label"]).
			arg("--numerators").arg(string(args.numerators)).
			arg("--denominator").arg(denominator).
			arg("--error_output").arg("./errorLogs.csv").
			saveFileContent("continueOrNot.txt").
			saveFile("errorLogs.csv").
			cache(24 * 60 * 60 * 1000).
			run()

	// This content is resolved in a sub-template only
	continueOrNot := continueCheck.getFileContent("continueOrNot.txt")

	errorLogsImportParams := pfErrorLogsConv.getColumns()
	errorLogsPf := xsv.importFile(continueCheck.getFile("errorLogs.csv"), "csv", errorLogsImportParams, { mem: defaultConvMem, cpu: defaultConvCpu })

	// Run differential analysis template
	// Analysis will only run if matrix is full rank (continueOrNot.txt content == "continue")
	diffAnalysis := render.create(diffAnalysisTpl, {
		continueOrNot: continueOrNot,
		allCounts: allCounts,
		csvCovariates: csvCovariates,
		numerators: args.numerators,
		denominator: denominator,
		contrastFactor: contrastFactor,
		params: {
			log2FcThreshold: log2FcThreshold,
			pAdjThreshold: pAdjThreshold,
			defaultConvMem: defaultConvMem,
			defaultConvCpu: defaultConvCpu,
			inputType: inputType
		},
		metaInputs: {
			blockId: blockId,
			customBlockLabel: args.customBlockLabel,
			defaultBlockLabel: args.defaultBlockLabel
		}
	})

	// Gather results from continueCheck template
	degPF := diffAnalysis.output("degPF")
	regDirPF := diffAnalysis.output("regDirPF")
	topDegPF := diffAnalysis.output("topDegPF")
	contrastExport := diffAnalysis.output("contrastExport")
	degPF_clonotype := diffAnalysis.output("degPF_clonotype")
	regDirPF_clonotype := diffAnalysis.output("regDirPF_clonotype")

	// @TODO: After fixing downstream block usage for axis based contrast remove this condition
	exports := {}
	if inputType == "Clonotype" || inputType == "Cluster" {
		exports = {
			DEG: degPF_clonotype,
			regDir: regDirPF_clonotype
		}
	} else {
		exports = {
			DEG: degPF,
			regDir: regDirPF,
			contrastExport: contrastExport
		}
	}

	return {
		outputs: {
			topTablePf: topDegPF,
			errorLogs: pframes.exportFrame(errorLogsPf)
		},
		exports: exports
	}
})


